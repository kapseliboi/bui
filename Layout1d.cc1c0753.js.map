{"version":3,"sources":["../node_modules/lit-virtualizer/lib/uni-virtualizer/lib/layouts/Layout1d.js"],"names":["Layout1d","Layout1dBase","constructor","config","_physicalItems","Map","_newPhysicalItems","_metrics","_anchorIdx","_anchorPos","_stable","_needsRemeasure","_nMeasured","_tMeasured","_estimate","updateItemSizes","sizes","Object","keys","forEach","key","metrics","mi","_getMetrics","Number","prevSize","_sizeDim","width","marginLeft","marginRight","height","marginTop","marginBottom","size","item","_getPhysicalItem","delta","undefined","console","warn","_updateItemSize","_scheduleReflow","_itemSize","Math","round","idx","get","_getSize","_getPosition","pos","_delta","_spacing","_calculateAnchor","lower","upper","_scrollSize","_viewDim1","_totalItems","max","min","floor","_getAnchor","_first","error","_last","firstItem","lastItem","firstMin","firstMax","lastMin","lastMax","maxIdx","minIdx","candidateIdx","candidate","cMin","cMax","_getActiveItems","_clearItems","_scrollPosition","_overhang","_getItems","_physicalMin","_physicalMax","items","clear","anchorSize","_itemDim1","anchorErr","_scrollError","set","extentErr","_calculateError","_updateScrollSize","_reflow","_scrollIfNeeded","_emitScrollSize","_updateVisibleIndices","_emitRange","_resetReflowState","_emitChildPositions","_emitScrollError","_getItemPosition","_positionDim","_secondaryPositionDim","_getItemSize","_secondarySizeDim","_itemDim2","_viewDim2Changed","remeasure","stable"],"mappings":"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","file":"Layout1d.cc1c0753.js","sourceRoot":"../demo","sourcesContent":["import { Layout1dBase } from './Layout1dBase.js';\nexport class Layout1d extends Layout1dBase {\n    constructor(config) {\n        super(config);\n        /**\n         * Indices of children mapped to their (position and length) in the scrolling\n         * direction. Used to keep track of children that are in range.\n         */\n        this._physicalItems = new Map();\n        /**\n         * Used in tandem with _physicalItems to track children in range across\n         * reflows.\n         */\n        this._newPhysicalItems = new Map();\n        /**\n         * Width and height of children by their index.\n         */\n        this._metrics = new Map();\n        /**\n         * anchorIdx is the anchor around which we reflow. It is designed to allow\n         * jumping to any point of the scroll size. We choose it once and stick with\n         * it until stable. _first and _last are deduced around it.\n         */\n        this._anchorIdx = null;\n        /**\n         * Position in the scrolling direction of the anchor child.\n         */\n        this._anchorPos = null;\n        /**\n         * Whether all children in range were in range during the previous reflow.\n         */\n        this._stable = true;\n        /**\n         * Whether to remeasure children during the next reflow.\n         */\n        this._needsRemeasure = false;\n        /**\n         * Number of children to lay out.\n         */\n        this._nMeasured = 0;\n        /**\n         * Total length in the scrolling direction of the laid out children.\n         */\n        this._tMeasured = 0;\n        this._estimate = true;\n    }\n    /**\n     * Determine the average size of all children represented in the sizes\n     * argument.\n     */\n    updateItemSizes(sizes) {\n        Object.keys(sizes).forEach((key) => {\n            const metrics = sizes[key], mi = this._getMetrics(Number(key)), prevSize = mi[this._sizeDim];\n            // TODO(valdrin) Handle margin collapsing.\n            // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing\n            mi.width = metrics.width + (metrics.marginLeft || 0) +\n                (metrics.marginRight || 0);\n            mi.height = metrics.height + (metrics.marginTop || 0) +\n                (metrics.marginBottom || 0);\n            const size = mi[this._sizeDim];\n            const item = this._getPhysicalItem(Number(key));\n            if (item) {\n                let delta;\n                if (size !== undefined) {\n                    item.size = size;\n                    if (prevSize === undefined) {\n                        delta = size;\n                        this._nMeasured++;\n                    }\n                    else {\n                        delta = size - prevSize;\n                    }\n                }\n                this._tMeasured = this._tMeasured + delta;\n            }\n        });\n        if (!this._nMeasured) {\n            console.warn(`No items measured yet.`);\n        }\n        else {\n            this._updateItemSize();\n            this._scheduleReflow();\n        }\n    }\n    /**\n     * Set the average item size based on the total length and number of children\n     * in range.\n     */\n    _updateItemSize() {\n        // Keep integer values.\n        this._itemSize[this._sizeDim] =\n            Math.round(this._tMeasured / this._nMeasured);\n    }\n    _getMetrics(idx) {\n        return (this._metrics[idx] = this._metrics[idx] || {});\n    }\n    _getPhysicalItem(idx) {\n        return this._newPhysicalItems.get(idx) || this._physicalItems.get(idx);\n    }\n    _getSize(idx) {\n        const item = this._getPhysicalItem(idx);\n        return item && item.size;\n    }\n    /**\n     * Returns the position in the scrolling direction of the item at idx.\n     * Estimates it if the item at idx is not in the DOM.\n     */\n    _getPosition(idx) {\n        const item = this._physicalItems.get(idx);\n        return item ? item.pos : (idx * (this._delta)) + this._spacing;\n    }\n    _calculateAnchor(lower, upper) {\n        if (lower === 0) {\n            return 0;\n        }\n        if (upper > this._scrollSize - this._viewDim1) {\n            return this._totalItems - 1;\n        }\n        return Math.max(0, Math.min(this._totalItems - 1, Math.floor(((lower + upper) / 2) / this._delta)));\n    }\n    _getAnchor(lower, upper) {\n        if (this._physicalItems.size === 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._first < 0) {\n            console.error('_getAnchor: negative _first');\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._last < 0) {\n            console.error('_getAnchor: negative _last');\n            return this._calculateAnchor(lower, upper);\n        }\n        const firstItem = this._getPhysicalItem(this._first), lastItem = this._getPhysicalItem(this._last), firstMin = firstItem.pos, firstMax = firstMin + firstItem.size, lastMin = lastItem.pos, lastMax = lastMin + lastItem.size;\n        if (lastMax < lower) {\n            // Window is entirely past physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        if (firstMin > upper) {\n            // Window is entirely before physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        if (firstMin >= lower || firstMax >= lower) {\n            // First physical item overlaps window, choose it\n            return this._first;\n        }\n        if (lastMax <= upper || lastMin <= upper) {\n            // Last physical overlaps window, choose it\n            return this._last;\n        }\n        // Window contains a physical item, but not the first or last\n        let maxIdx = this._last, minIdx = this._first;\n        while (true) {\n            const candidateIdx = Math.round((maxIdx + minIdx) / 2), candidate = this._physicalItems.get(candidateIdx), cMin = candidate.pos, cMax = cMin + candidate.size;\n            if ((cMin >= lower && cMin <= upper) ||\n                (cMax >= lower && cMax <= upper)) {\n                return candidateIdx;\n            }\n            else if (cMax < lower) {\n                minIdx = candidateIdx + 1;\n            }\n            else if (cMin > upper) {\n                maxIdx = candidateIdx - 1;\n            }\n        }\n    }\n    /**\n     * Updates _first and _last based on items that should be in the current\n     * viewed range.\n     */\n    _getActiveItems() {\n        if (this._viewDim1 === 0 || this._totalItems === 0) {\n            this._clearItems();\n        }\n        else {\n            const upper = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang), lower = Math.max(0, upper - this._viewDim1 - (2 * this._overhang));\n            this._getItems(lower, upper);\n        }\n    }\n    /**\n     * Sets the range to empty.\n     */\n    _clearItems() {\n        this._first = -1;\n        this._last = -1;\n        this._physicalMin = 0;\n        this._physicalMax = 0;\n        const items = this._newPhysicalItems;\n        this._newPhysicalItems = this._physicalItems;\n        this._newPhysicalItems.clear();\n        this._physicalItems = items;\n        this._stable = true;\n    }\n    /*\n     * Updates _first and _last based on items that should be in the given range.\n     */\n    _getItems(lower, upper) {\n        const items = this._newPhysicalItems;\n        // The anchorIdx is the anchor around which we reflow. It is designed to\n        // allow jumping to any point of the scroll size. We choose it once and\n        // stick with it until stable. first and last are deduced around it.\n        if (this._anchorIdx === null || this._anchorPos === null) {\n            this._anchorIdx = this._getAnchor(lower, upper);\n            this._anchorPos = this._getPosition(this._anchorIdx);\n        }\n        let anchorSize = this._getSize(this._anchorIdx);\n        if (anchorSize === undefined) {\n            anchorSize = this._itemDim1;\n        }\n        // Anchor might be outside bounds, so prefer correcting the error and keep\n        // that anchorIdx.\n        let anchorErr = 0;\n        if (this._anchorPos + anchorSize + this._spacing < lower) {\n            anchorErr = lower - (this._anchorPos + anchorSize + this._spacing);\n        }\n        if (this._anchorPos > upper) {\n            anchorErr = upper - this._anchorPos;\n        }\n        if (anchorErr) {\n            this._scrollPosition -= anchorErr;\n            lower -= anchorErr;\n            upper -= anchorErr;\n            this._scrollError += anchorErr;\n        }\n        // TODO @straversi: If size is always itemDim1, then why keep track of it?\n        items.set(this._anchorIdx, { pos: this._anchorPos, size: anchorSize });\n        this._first = (this._last = this._anchorIdx);\n        this._physicalMin = (this._physicalMax = this._anchorPos);\n        this._stable = true;\n        while (this._physicalMin > lower && this._first > 0) {\n            let size = this._getSize(--this._first);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._itemDim1;\n            }\n            const pos = (this._physicalMin -= size + this._spacing);\n            items.set(this._first, { pos, size });\n            if (this._stable === false && this._estimate === false) {\n                break;\n            }\n        }\n        while (this._physicalMax < upper && this._last < this._totalItems) {\n            let size = this._getSize(this._last);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._itemDim1;\n            }\n            items.set(this._last++, { pos: this._physicalMax, size });\n            if (this._stable === false && this._estimate === false) {\n                break;\n            }\n            else {\n                this._physicalMax += size + this._spacing;\n            }\n        }\n        this._last--;\n        // This handles the cases where we were relying on estimated sizes.\n        const extentErr = this._calculateError();\n        if (extentErr) {\n            this._physicalMin -= extentErr;\n            this._physicalMax -= extentErr;\n            this._anchorPos -= extentErr;\n            this._scrollPosition -= extentErr;\n            items.forEach((item) => item.pos -= extentErr);\n            this._scrollError += extentErr;\n        }\n        if (this._stable) {\n            this._newPhysicalItems = this._physicalItems;\n            this._newPhysicalItems.clear();\n            this._physicalItems = items;\n        }\n    }\n    _calculateError() {\n        if (this._first === 0) {\n            return this._physicalMin;\n        }\n        else if (this._physicalMin <= 0) {\n            return this._physicalMin - (this._first * this._delta);\n        }\n        else if (this._last === this._totalItems - 1) {\n            return this._physicalMax - this._scrollSize;\n        }\n        else if (this._physicalMax >= this._scrollSize) {\n            return ((this._physicalMax - this._scrollSize) +\n                ((this._totalItems - 1 - this._last) * this._delta));\n        }\n        return 0;\n    }\n    _updateScrollSize() {\n        // Reuse previously calculated physical max, as it might be higher than the\n        // estimated size.\n        super._updateScrollSize();\n        this._scrollSize = Math.max(this._physicalMax, this._scrollSize);\n    }\n    // TODO: Can this be made to inherit from base, with proper hooks?\n    _reflow() {\n        const { _first, _last, _scrollSize } = this;\n        this._updateScrollSize();\n        this._getActiveItems();\n        this._scrollIfNeeded();\n        if (this._scrollSize !== _scrollSize) {\n            this._emitScrollSize();\n        }\n        this._updateVisibleIndices();\n        this._emitRange();\n        if (this._first === -1 && this._last === -1) {\n            this._resetReflowState();\n        }\n        else if (this._first !== _first || this._last !== _last ||\n            this._needsRemeasure) {\n            this._emitChildPositions();\n            this._emitScrollError();\n        }\n        else {\n            this._emitChildPositions();\n            this._emitScrollError();\n            this._resetReflowState();\n        }\n    }\n    _resetReflowState() {\n        this._anchorIdx = null;\n        this._anchorPos = null;\n        this._stable = true;\n    }\n    /**\n     * Returns the top and left positioning of the item at idx.\n     */\n    _getItemPosition(idx) {\n        return {\n            [this._positionDim]: this._getPosition(idx),\n            [this._secondaryPositionDim]: 0,\n        };\n    }\n    /**\n     * Returns the height and width of the item at idx.\n     */\n    _getItemSize(idx) {\n        return {\n            [this._sizeDim]: this._getSize(idx) || this._itemDim1,\n            [this._secondarySizeDim]: this._itemDim2,\n        };\n    }\n    _viewDim2Changed() {\n        this._needsRemeasure = true;\n        this._scheduleReflow();\n    }\n    _emitRange() {\n        const remeasure = this._needsRemeasure;\n        const stable = this._stable;\n        this._needsRemeasure = false;\n        super._emitRange({ remeasure, stable });\n    }\n}\n"]}